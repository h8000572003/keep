<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on 學習筆記</title>
    <link>https://h8000572003.github.io/keep/</link>
    <description>Recent content in Home on 學習筆記</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>utf-8</language>
    <lastBuildDate>Thu, 19 Mar 2020 20:59:39 +0800</lastBuildDate>
    
	<atom:link href="https://h8000572003.github.io/keep/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>PMD</title>
      <link>https://h8000572003.github.io/keep/pmd/</link>
      <pubDate>Thu, 19 Mar 2020 20:59:39 +0800</pubDate>
      
      <guid>https://h8000572003.github.io/keep/pmd/</guid>
      <description>簡介 PMD 是來執行 Java 程式檢測的工具，檢測的對象是原始程式碼。雖然 PMD 看起來像是一個縮寫字，但是作者表示當初採用這個字純粹只是因為這幾個單字念起來很順口。根據網站上面的介紹， PMD 可以找出下列問題：
 疑似的臭蟲 (possible bugs)，例如空的 try/catch/finally/switch 描述句。 無法執行的程式碼 (dead code)，例如未使用的 local 變數、參數、或是 private 函數。 不良的程式碼 (suboptimal code)，例如效率不良的使用 String/StringBuffer 過於複雜的語法 (overcomplicated expressions)，例如不必要的 if 描述句，可以用 while 迴圈取代的 for 迴圈。 重複的程式碼 (duplicated code)，剪貼的程式碼表示臭蟲也被複製了。 PMD 本身沒有提供圖形化的介面，而必須透過命令列的方式加以操作。當然在支援 Ant 方面， PMD 是沒有問題的。除此之外，更支援 Maven 1/2 的開發環境。而對於多數程式開發人員關心的 IDE 支援度方面，幾乎市面上主要的 IDE 都受其支援。以此看來，要在大多數的開發環境下使用 PMD 幾乎是沒有甚麼門檻。  </description>
    </item>
    
    <item>
      <title>關於我</title>
      <link>https://h8000572003.github.io/keep/about/about/</link>
      <pubDate>Thu, 19 Mar 2020 17:00:28 +0800</pubDate>
      
      <guid>https://h8000572003.github.io/keep/about/about/</guid>
      <description>Hello JAVA
public class Me{ public void printSkills(){ System.out.println(&amp;quot;JAVA&amp;quot;); ...(&amp;quot;restful&amp;quot;); ...(&amp;quot;WebService&amp;quot;); ...(&amp;quot;Struts&amp;quot;); ...(&amp;quot;Spring&amp;quot;); ...(&amp;quot;JSP&amp;quot;); ...(&amp;quot;JSF&amp;quot;); ...(&amp;quot;SVN&amp;quot;); ...(&amp;quot;GIT&amp;quot;); } public void joinProject(){ ...(&amp;quot;戶役政&amp;quot;); ...(&amp;quot;台中公車android&amp;quot;); ...(&amp;quot;OPEN DATA&amp;quot;); ...(&amp;quot;國產署&amp;quot;); } public void learn(){ //TODO } } </description>
    </item>
    
    <item>
      <title>FindBug</title>
      <link>https://h8000572003.github.io/keep/findbug/</link>
      <pubDate>Tue, 17 Mar 2020 23:14:02 +0800</pubDate>
      
      <guid>https://h8000572003.github.io/keep/findbug/</guid>
      <description>同樣是用來檢測 Java 程式的工具，其檢測的對象是 Byte Code (class 或是 jar 檔)。儘管如此，FindBugs 依舊是屬於靜態分析的方式。FindBugs 如其名，主要是利用 Bug Patterns 的概念，找尋出程式中有問題 (Bugs) 的程式碼 。在其官方的網站中提到 Bug Patterns 的產生可能有下列因素： 程式語言本身不容易使用的功能 (Difficult language features) 被誤用的 API (Misunderstood API methods) 當程式碼在維護時，不變的條件被誤解了 (Misunderstood invariants when code is modified during maintenance) 其他常見的錯誤，例如打錯字、或是使用了錯誤的布林運算元 (Garden varieity mistakes: typos, use of the wrong boolean operator) FindBugs 本身提供完整的 GUI 介面，讓使用者可以很方便地進行檢測的工作。因為 FindBugs 主要使用 Java 進行開發，所以可以運行於各種的作業系統上。雖然 FindBugs 是針對 ByteCode 進行掃描，但是在 GUI 中我們可以指定原始程式碼所在的目錄。如此一來， FindBugs 就會自動將發現問題的 ByteCode 與原始程式碼自動連結並加以顯示。 eclipse plus
http://findbugs.cs.umd.edu/eclipse</description>
    </item>
    
  </channel>
</rss>